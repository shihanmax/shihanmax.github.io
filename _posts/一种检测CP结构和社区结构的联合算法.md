---
title:  "一种检测CP结构和社区结构的联合算法"
date:   2018-12-20 00:00:00
categories: 算法
tags:  CP
syntaxHighlighter: yes
Mathjax: true
---
Bing-Bing Xiang et.al

## Abstract

C-P结构和社区结构是复杂网络中的两种典型的中尺度结构。社区发现已经被广泛研究，而C-P结构的定义和检测相关的研究却不多。并且，目前社区结构的检测和C-P结构的检测是分开进行的。本文中，我们提出了一种同时检测复杂网络中的C-P结构和社区结构的联合框架（在两种结构之间搭建了一个桥梁）。我们的算法具有以下优点：可以检测多C-P结构；可以检测社区之间的重叠节点；通过调整参数，可以检测大小不同的核心（core）。我们在人工网络和真实网络上验证了我们算法的优良效果。总结一下：我们提出了一种同时检测复杂网络中的C-P结构和社区结构的联合框架。

<!--more-->

## I. INTRODUCTION

真实世界中，通讯、社会、运输、生物等等领域都可以描述为一个网络，网络的中尺度结构对于了解网络特性和动态（dynamics）非常重要。一种典型的中尺度结构——社区已经被广泛研究：同一个社区中的结点间紧密相连，而社区间则链接稀疏。社区发现有多种算法，如基于模块化的[^6]，基于随机游走的[^7]，基于谱聚类的[^8]，基于层级聚类的[^9,10]，基于非负矩阵分解方法的，等等。也有很多用来研究社区重叠（overlapping community detection）的算法，如标签传播[^12,13]，连接分块（link partition）[^14,15]，团渗透理论[^16,17]，多目标演化算法[^18]等。

另一种中尺度结构是C-P结构，它没有受到太多的关注和研究，但研究表明，在社会网络[^19]，科学引文网络[^20]，国际贸易[^21,22]，以及其他领域[^23-25]都包含C-P结构。

虽然这种结构都或多或少受到了研究，但它们之间的关系却不明确，事实上，从直觉来看，它们之间是有一定联系的：一方面，具有单C-P结构的网络一般都不包含社区结构；另一方面，具有多个C-P结构的网络一般暗示着存在社区结构。然而，存在社区则不一定存在C-P结构。因此，正确理解两种结构之间的关系有助于我们设计有效地方法来同时识别二者。

目前较为流行和正式的对C-P结构的定义来自B和E[^27]，在定义中，一个节点如果既和其他核心节点相连，又和边缘节点相连，则该节点也属于核心；而边缘节点之间则没有连接。由于理想的C-P结构太严格了，一个稍微宽松一些的定义是：核心节点大部分紧密相连，而边缘节点则呈树状（frays into a tree，有待商榷），当然，这只是一个描述性的定义，并没有很严谨的数学定义。目前已有的C-P结构检测方法主要是通过检测一个网络究竟和理想C-P结构有多大相似度来进行的[^7,28,31]，或者是将节点按照一定的中心性（coreness）来排序。最近，Zhang等人首次提出了通过最大似然方法来拟合随机块矩阵来检测C-P结构的方法。通过对网络数据的拟合，模型可以给出最佳的关于C-P结构的划分。这个方法不需要额外参数，能够适用于大型网络和弱C-P结构网络。然而，这些方法往往会有以下缺点：事先需要给定核的大小；将网络看做单C-P结构来处理（实际情况表明许多网络含有不只一个C-P结构）；然而，在许多网络中可能存在着社区结构和读个C-P结构，这些算法并不能提供一个同时检测这两种结构的框架。

受上述原因启发，这篇文章的目标是提出一个可同时检测C-P结构和社区结构的联合框架，为了达到这个目标，我们的实现方案是：

1. 基于**连接密度**（connection density indictor）对所有节点重新排序
2. 通过我们定义的**区域密度曲线**判断网络是否显示含有单C-P、多C-P或社区结构

多说一句，多尺度的C-P结构以及节点重叠的情况，也能检测。

## II. THE PROPOSED ALGORITHM

这一节里，我们会介绍一下我们的算法，考虑一个无向无权图（我们的算法会在附录中介绍），算法主要分为三个步骤：

1. 将所有节点重新排序
2. 计算每个节点的区域密度
3. 通过区域密度曲线来检测这些中尺度结构

### A. Re-rank nodes in a new sequence 对节点重新排序

N考虑一个图$G(V,E)$，$V$是节点集合，$E$是边的集合。已知核心之间的连接很紧密，所以我们希望把所有的节点重新排序，使得具有公共连接的结点互相之间更接近（such that nodes with more common connections approch each other in the new seqence）。为了达到这个目的，我们定义了集合$U$和集合$V'$，$V'=V-U$（这两个集合都是节点集合，原图中的结点如果不在$U$中，就在$V'$中，$V'$是$U$的补集）。初始状态，$U$为空集，$V'=V$为节点集合，为了启动排序过程，我们需要选择一个初始的节点，我们可以选择中心性强的那个节点作为初始节点（因为这个节点更有可能是核心节点），这里我们选择closeness最大的那个节点（我们后来发现，最初这个节点按照度最大、betweeness最大等等来选择，结果都不会有很大影响），并将它重新编号为$u1$，这时$U=\left \{u1\right\}$，现在我们需要从$V'$里再选择一个节点加入到$U$中，而且要保证，新加入的这个节点一定要和$U$中的结点的连边数最大，如果这样的节点不止一个，那我们选择度最大的那个，放到$U$集合中。（如果两个节点和集合$U$中的连边数相同，度也相同呢？这种情况下，随机选择一个）。持续上述过程，直到集合$V'$为空，我们就得到了一个新的节点序列$U=\left\{u_1,u_2,...,u_N\right\}$

### B. Plot region density curve 绘制区域密度曲线

现在，我们提出一个局部指示器——连接密度$CD$（connection density）来代表子图$S$中的连接密度情况：

$$CD(S)=\cfrac{2m'}{n'(n'-1)}$$

其中，$m'$表示$S$子图中的连边数；$n'$表示子图节点个数。

这里定义一个参数$\alpha$用来衡量核所包含的最少的节点数。对给定$\alpha$，一个节点$u_i$的区域密度定义为：

$$ RD(U_i)=\left\{ \begin{aligned} &CD (\left\{u_1,...,u_i\right\})\ \ \ \ \   i\le\alpha;\\ &CD(\left\{u_{i-\alpha+1,...,u_i}\right\})\ \ \ \ i>\alpha. \end{aligned} \right. $$
